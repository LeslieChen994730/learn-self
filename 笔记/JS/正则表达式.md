[TOC]

## 概念和创建方式

普通字符串和特殊字符串组成的文字模式，匹配一个或多个字符串，查找，匹配，替换，数据验证；

1.  **构造函数**(可以传入参数代替，字面量不行)

    ```js
    var reg = new RegExp('String', '修饰符');
    var reg = new RegExp(/fdsfsd/g, '修饰符');(es6)
    ```

2.  **字面量**

    ```js
    var reg = /\d/gi;
    ```

3.  **转义字符**

    ```js
    \  \n换行  \t跳行   构造函数转义专用\\
    ```

4.  **修饰符**

    *   **g**：表示全局匹配，模式将被应用到所有字符串，而不是在发现第一个匹配项时停止

    *   **i**：表示不区分大小写

    *   **m**：表示多行模式

    *   **u**：会正确处理大于`\uFFFF`的Unicode，意味着4个字节的Unicode字符也可以被支持了

    *   **y**：开始从位置0开始，后一次匹配都从上一次匹配成功的下一个位置开始

        

## 基础

1.  **字符类（单个匹配）**

    ==[]表示匹配[]里任意一个字符，先匹配就先结束，[^]表示取反，匹配除了该[]里字符任意一个。==

    ==**/\d/**匹配数字,**/\s/**匹配空格和tab，**/\w/**匹配[0-9a-zA-Z_]==,**/./**匹配换行符之外所有(大写字母为取反)

2.  **量词｛n，m｝**

    ==表示最少n次，最多m次,**?**={0,1},*={0,},+{1,}==

3.  **非贪婪匹配（？）**

4.  **选择（|）**

5.  **分组（（））**

    ```js
    /(ab)c/单独捕获（输出组） =>['abc','ab']
    /(?:ab)c/不输出组元素   =>['abc']
    ```

6.  **位置匹配**

    ```js
    首匹配/^/       尾匹配/$/       单词边界/b/     前瞻性匹配/java(?=script)/      负前瞻性匹配/java(?!script)/
    ```

    ```js
    'adobe12ps15test'.match(/[a-z]+(\d+)([a-z]+)/);
    // ["adobe12ps", "12", "ps"]
    
    'adobe12ps15test'.match(/[a-z]+(?:\d+)([a-z]+)/); //(?:n) 表示非捕获组
    // ["adobe12ps", "ps"]
    
    'adobe12ps15test'.match(/[a-z]+(?=\d)/g);//(?=n) 匹配任何其后紧跟字符n的字符串
    // ["adobe", "ps"]
    
    'adobe12ps15test'.match(/[a-z]+(?!\d)/g);//(?!n) 匹配任何其后没有紧跟字符n的字符串
    // ["adob", "p", "test"]
    
    
    'adobe12ps15test'.match(/(?<=\d)[a-z]+/g);//(?<=n) 匹配任何其前紧跟字符n的字符串
    // ["ps", "test"]
    
    'adobe12ps15test'.match(/(?<!\d)[a-z]+/g);//(?<!n ) 匹配任何其前紧跟字符n的字符串
    // ["adobe", "s", "est"]
    ```

    

## 方法

1.  **RegExp对象相关方法**

    <img src="C:\Users\chenz\Desktop\笔记\JS\图片\正则方法.png"  />

2.  **String对象相关方法**

    <img src="C:\Users\chenz\Desktop\笔记\JS\图片\正则String方法.png"  />

    **replace**高级用法

    在只有一个匹配项的情况下，会传递3个参数给这个函数：==模式的匹配项、匹配项在字符串中的位置、原始字符串==。

    在有多个捕获组的情况下，传递的参数是==模式匹配项、第一个捕获组、第二个、第三个...最后两个参数是模式的匹配项在字符串位置、原始字符串==。

    ==这个函数要返回一个字符串，表示要替换掉的匹配项==。

    ```js
    'adobe aacc bbaa'.replace(/a+/g, function(str, index, source){
        if(index > 0){
            return str.toUpperCase();
        } else {
            return str;
        }
    });
    // "adobe AAcc bbAA"
    ```

    

## 常用正则表达式

```js
验证数字：^[0-9]*$ 
验证n位的数字：^\d{n}$ 
验证至少n位数字：^\d{n,}$ 
验证m-n位的数字：^\d{m,n}$ 
验证零和非零开头的数字：^(0|[1-9][0-9]*)$ 
验证有两位小数的正实数：^[0-9]+(.[0-9]{2})?$ 
验证有1-3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$ 
验证非零的正整数：^\+?[1-9][0-9]*$ 
验证非零的负整数：^\-[1-9][0-9]*$ 
验证非负整数（正整数 + 0）： ^\d+$ 
验证非正整数（负整数 + 0）： ^((-\d+)|(0+))$ 
验证长度为3的字符：^.{3}$ 
验证由26个英文字母组成的字符串：^[A-Za-z]+$ 
验证由26个大写英文字母组成的字符串：^[A-Z]+$ 
验证由26个小写英文字母组成的字符串：^[a-z]+$ 
验证由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$ 
验证由数字、26个英文字母或者下划线组成的字符串：^\w+$ 
验证用户密码：^[a-zA-Z]\w{5,17}$     正确格式为：以字母开头，长度在6-18之间，只能包含字符、数字和下划线。 
验证是否含有 ^%&',;=?$\" 等字符：[^%&',;=?$\x22]+ 
验证汉字：^[\u4e00-\u9fa5],{0,}$ 
验证Email地址：/^([a-zA-Z0-9]+[_|\_|\.]?)*[a-zA-Z0-9]+@([a-zA-Z0-9]+[_|\_|\.]?)*[a-zA-Z0-9]+\.[a-zA-Z]{2,3}$/
验证InternetURL：^http://([\w-]+\.)+[\w-]+(/[\w-./?%&=]*)?$ ；^[a-zA-z]+://(w+(-w+)*)(.(w+(-w+)*))*(?S*)?$ 
验证电话号码：^(\(\d{3,4}\)|\d{3,4}-)?\d{7,8}$：   --正确格式为：XXXX-XXXXXXX，XXXX-XXXXXXXX，XXX-XXXXXXX，XXX-XXXXXXXX，XXXXXXX，XXXXXXXX。 
验证身份证号（15位或18位数字）：^\d{15}|\d{}18$ 
验证一年的12个月：^(0?[1-9]|1[0-2])$ 正确格式为：“01”-“09”和“1”“12” 
验证一个月的31天：^((0?[1-9])|((1|2)[0-9])|30|31)$ 正确格式为：01、09和1、31。 
整数：^-?\d+$ 
非负浮点数（正浮点数 + 0）：^\d+(\.\d+)?$ 
正浮点数： ^(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*))$ 
非正浮点数（负浮点数 + 0）： ^((-\d+(\.\d+)?)|(0+(\.0+)?))$ 
负浮点数 ：^(-(([0-9]+\.[0-9]*[1-9][0-9]*)|([0-9]*[1-9][0-9]*\.[0-9]+)|([0-9]*[1-9][0-9]*)))$ 
浮点数： ^(-?\d+)(\.\d+)?$
验证身份证：/(^\d{15}$)|(^\d{18}$)|(^\d{17}(\d|X|x)$)/
```



[TOC]